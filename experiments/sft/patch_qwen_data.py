#!/usr/bin/env python3
"""
Qwen Data Patch Script
Directly patches Qwen's __init__.py file to add MindCube datasets.
This is more reliable than runtime injection.
"""

import os
import shutil
import sys
from datetime import datetime

def get_project_root():
    """Get the project root directory (MindCube level)"""
    # Script is at: MindCube/experiments/sft/patch_qwen_data.py
    script_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.abspath(os.path.join(script_dir, '..', '..'))
    return project_root

PROJECT_ROOT = get_project_root()
QWEN_INIT_FILE = os.path.join(PROJECT_ROOT, "Qwen2.5-VL-MindCube/qwen-vl-finetune/qwenvl/data/__init__.py")
BACKUP_FILE = os.path.join(PROJECT_ROOT, "experiments/sft/qwen_data_init_backup.py")

# MindCube data configurations - following the same naming pattern as original Qwen datasets
MINDCUBE_DATASETS = [
    ("RAW_QA_SFT", "raw_qa", "MindCube_train_raw_qa_qwen_sft.json"),
    ("AUG_CGMAP_OUT_SFT", "aug_cgmap_out", "MindCube_train_aug_cgmap_out_qwen_sft.json"),
    ("PLAIN_CGMAP_OUT_SFT", "plain_cgmap_out", "MindCube_train_plain_cgmap_out_qwen_sft.json"),
    ("FF_RSN_SFT", "ff_rsn", "MindCube_train_ff_rsn_qwen_sft.json"),
    ("AUG_CGMAP_FFR_OUT_SFT", "aug_cgmap_ffr_out", "MindCube_train_aug_cgmap_ffr_out_qwen_sft.json"),
    ("PLAIN_CGMAP_FFR_OUT_SFT", "plain_cgmap_ffr_out", "MindCube_train_plain_cgmap_ffr_out_qwen_sft.json"),
    ("CGMAP_IN_FFR_OUT_SFT", "cgmap_in_ffr_out", "MindCube_train_cgmap_in_ffr_out_qwen_sft.json"),
]

def generate_dataset_definitions():
    """Generate dataset definitions following the original Qwen pattern"""
    definitions = []
    for var_name, _, filename in MINDCUBE_DATASETS:
        definition = f"""{var_name} = {{
    "annotation_path": "{PROJECT_ROOT}/data/prompts/training/qwen2.5vl/{filename}",
    "data_path": "{PROJECT_ROOT}/data/",
}}"""
        definitions.append(definition)
    return "\n\n".join(definitions)

def generate_data_dict_entries():
    """Generate data_dict entries"""
    entries = []
    for var_name, key, _ in MINDCUBE_DATASETS:
        entries.append(f'    "{key}": {var_name},')
    return "\n".join(entries)

def backup_original():
    """Create backup of original __init__.py"""
    if not os.path.exists(BACKUP_FILE):
        print(f"Creating backup: {BACKUP_FILE}")
        shutil.copy2(QWEN_INIT_FILE, BACKUP_FILE)
    else:
        print(f"Backup already exists: {BACKUP_FILE}")

def restore_original():
    """Restore original __init__.py from backup"""
    if os.path.exists(BACKUP_FILE):
        print(f"Restoring original file from backup...")
        shutil.copy2(BACKUP_FILE, QWEN_INIT_FILE)
        print("✅ Original file restored")
        return True
    else:
        print("❌ No backup file found!")
        return False

def patch_init_file():
    """Patch the __init__.py file to add MindCube datasets"""
    
    # Read original file
    with open(QWEN_INIT_FILE, 'r') as f:
        content = f.read()
    
    # Check if already patched
    if "# ===== MindCube Datasets" in content:
        print("⚠️  File already patched with MindCube datasets")
        return True
    
    # Find the VIDEOCHATGPT definition to insert after it
    videochatgpt_start = content.find("VIDEOCHATGPT = {")
    if videochatgpt_start == -1:
        print("❌ Could not find VIDEOCHATGPT definition!")
        return False
    
    # Find the end of VIDEOCHATGPT definition
    brace_count = 0
    i = videochatgpt_start
    while i < len(content):
        if content[i] == '{':
            brace_count += 1
        elif content[i] == '}':
            brace_count -= 1
            if brace_count == 0:
                break
        i += 1
    
    # Find the end of line after the closing brace
    insertion_point = content.find('\n', i) + 1
    
    # Generate MindCube dataset definitions
    mindcube_definitions = f"""
# ===== MindCube Datasets (Auto-generated by patch_qwen_data.py) =====
{generate_dataset_definitions()}
# ===== End MindCube Datasets =====

"""
    
    # Insert MindCube definitions
    new_content = content[:insertion_point] + mindcube_definitions + content[insertion_point:]
    
    # Now find and update data_dict
    data_dict_start = new_content.find('data_dict = {')
    if data_dict_start == -1:
        print("❌ Could not find data_dict definition!")
        return False
    
    # Find the closing brace of data_dict
    brace_count = 0
    data_dict_end = data_dict_start
    for i, char in enumerate(new_content[data_dict_start:], data_dict_start):
        if char == '{':
            brace_count += 1
        elif char == '}':
            brace_count -= 1
            if brace_count == 0:
                data_dict_end = i
                break
    
    # Find the last entry in data_dict (before the closing brace)
    dict_content = new_content[data_dict_start:data_dict_end]
    
    # Insert MindCube entries before the closing brace
    mindcube_entries = f"""    # MindCube datasets (Auto-generated by patch_qwen_data.py)
{generate_data_dict_entries()}
"""
    
    new_dict_content = dict_content + "\n" + mindcube_entries
    final_content = new_content[:data_dict_start] + new_dict_content + new_content[data_dict_end:]
    
    # Write patched file
    with open(QWEN_INIT_FILE, 'w') as f:
        f.write(final_content)
    
    print("✅ Successfully patched Qwen __init__.py with MindCube datasets")
    return True

def verify_patch():
    """Verify that the patch was applied correctly"""
    with open(QWEN_INIT_FILE, 'r') as f:
        content = f.read()
    
    # Check for MindCube datasets in data_dict
    expected_keys = [key for _, key, _ in MINDCUBE_DATASETS]
    found_datasets = []
    
    for key in expected_keys:
        if f'"{key}":' in content:
            found_datasets.append(key)
    
    print(f"Found {len(found_datasets)}/{len(expected_keys)} MindCube datasets in data_dict:")
    for dataset in found_datasets:
        print(f"  ✅ {dataset}")
    
    missing = set(expected_keys) - set(found_datasets)
    if missing:
        print("Missing datasets:")
        for dataset in missing:
            print(f"  ❌ {dataset}")
        return False
    
    return True

def main():
    if len(sys.argv) < 2:
        print("Usage: python patch_qwen_data.py [patch|restore|verify]")
        sys.exit(1)
    
    command = sys.argv[1]
    
    print("=" * 60)
    print("Qwen Data Patch Script")
    print("=" * 60)
    print(f"Project root: {PROJECT_ROOT}")
    print(f"Target file: {QWEN_INIT_FILE}")
    print(f"Command: {command}")
    print()
    
    if command == "patch":
        backup_original()
        if patch_init_file():
            verify_patch()
        else:
            print("❌ Patching failed!")
            sys.exit(1)
            
    elif command == "restore":
        restore_original()
        
    elif command == "verify":
        if not verify_patch():
            sys.exit(1)
        
    else:
        print(f"❌ Unknown command: {command}")
        print("Available commands: patch, restore, verify")
        sys.exit(1)

if __name__ == "__main__":
    main() 